#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : enable



#define PROBE_USE_SH_COLOR
// #define PROBE_USE_IMAGE_COLOR
#define PROBE_USE_IMAGE_DEPTH

#include "rng.glsl"
#include "utl.glsl"
#include "raycommon.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba16f) uniform image2D uProbeTexture[2];

// layout(binding = 1, set = 0, rgba16f) uniform image2D visibility;
layout(binding = 2, set = 0) uniform sampler2D uTextureCache[4096];
// layout(binding = 3, set = 0) uniform CameraProperties 
// {
// 	mat4 viewInverse;
// 	mat4 projInverse;
// } cam;
#include "material.glsl"

layout(std430, set = 0, binding = 5, scalar) buffer ProbeBuffer {
	LightProbe probes[];
};

layout(std430, set = 0, binding = 6, scalar) readonly buffer ProbeSettingsBuffer {
	LightProbeSettings probe_settings;
};

layout(location = 0) rayPayloadEXT RayData data;
layout(location = 2) rayPayloadEXT bool shadowed;

layout( push_constant ) uniform constants
{
    uint kFrame;
    uint kSuperSample;
};

#define SAMPLE_COUNT 2


vec3 light_probe_irradiance(vec3 p, vec3 n, LightProbeSettings settings) {
    ivec3 min_index = light_probe_probe_index(settings, p);

	LightProbe neighbors[8];
	for (uint i = 0; i < 8; i++) {
		uvec3 offset = uvec3(i, i>>1, i>>2) & 1;
		neighbors[i] = probes[index_3d(settings.dim, min_index + ivec3(offset))];
	}


    // return (stupid_light_probe_irradiance(p, n, neighbors, settings));
    return (light_probe_irradiance(p, n, neighbors, settings));
}

void main() 
{

    uint probe_id = gl_LaunchIDEXT.x;
    LightProbe probe = probes[probe_id];

    uvec3 probe_coord = index_1d(probe_settings.dim, probes[probe_id].id);

    uint seed = tea(probe_id, probe.samples);

    vec2 color_texture_size = imageSize(uProbeTexture[0]).xy;
    vec2 visibility_texture_size = imageSize(uProbeTexture[1]).xy;
    vec2 color_texture_rcp = 1.0/imageSize(uProbeTexture[0]).xy;
    vec2 visibility_texture_rcp = 1.0/imageSize(uProbeTexture[1]).xy;
    vec2 color_topleft = probe_color_pixel(probe_coord, probe_settings.dim);
    vec2 depth_topleft = probe_depth_pixel(probe_coord, probe_settings.dim);

    vec3 grid_size = light_probe_grid_size(probe_settings);
    float grid_max_distance  = dot(grid_size,grid_size);

    // uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, kFrame);


    if (kSuperSample>0) {
        // for (int i = 0; i < 9; i++) {
        //     probes[probe_id].irradiance.irradiance[i] = vec3(0.0);
        // }
        // probes[probe_id].irradiance = sh_identity();
        // probes[probe_id].samples = 0;
    }
    if (probes[probe_id].samples > 320) {

        // return;
    }

	vec4 origin = vec4(probe.p, 1.0);

	float tmin = 0.0;
	float tmax = 10000.0;


    vec3 image_color = vec3(0.0);


    uint num_samples = max(1, 64 * kSuperSample);

    for (uint i = 0; i < num_samples; i++) {
        float r0 = rnd(seed) * 2. - 1.;
        float r1 = rnd(seed) * 2. - 1.;
        float r2 = rnd(seed) * 2. - 1.;
        vec4 direction = vec4(normalize(vec3(r0,r1,r2)), 0);
        
        vec3 color=vec3(0.0);
        data.normal = direction.xyz;
        data.color = vec3(0.0);
        data.distance = 0.0;

        vec2 color_uv = probe_color_uv(probe_coord, direction.xyz, probe_settings.dim, color_texture_rcp);
        ivec2 color_pixel = ivec2(color_uv * color_texture_size);
        vec2 depth_uv = probe_depth_uv(probe_coord, direction.xyz, probe_settings.dim, visibility_texture_rcp);

        vec3 current_color = imageLoad(uProbeTexture[0], color_pixel).rgb;
        vec2 current_depth = imageLoad(uProbeTexture[1], ivec2(depth_uv * visibility_texture_size)).rg;

        traceRayEXT(topLevelAS, 
            gl_RayFlagsNoneEXT, 
            // gl_RayFlagsOpaqueEXT, 
            0xff, 
            0, 
            0, 
            0, 
            origin.xyz, 
            tmin, 
            direction.xyz, 
            tmax, 
            0);


        vec3 bounce_dir = data.normal.xyz;
        vec3 h = origin.xyz + direction.xyz * data.distance + bounce_dir * 0.01;


        // direction.xyz *= -1.0f;
        // direction.xyz = -data.normal.xyz;

        // vec3 bounce_dir = -direction.xyz;
            
        if (data.distance < 0.0) {
            color += data.color;
        } else {
            // if (kFrame > 512)
                color += light_probe_irradiance(h, bounce_dir, probe_settings) * 0.95;
                        
            // color += 10.0 * data.color / 3.1415;
            // color += 1.0 * data.color;
            color *= 1.0 * data.color / 3.1415;

        } 
        // color = pow(color, vec3(2.2));
         


        // stupid_radiance_encoding(probes[probe_id].irradiance, direction.xyz, color, probes[probe_id].samples); 
        // direction.xyz = texel_dir;
        // if (abs(direction.x) > abs(direction.y) && abs(direction.x) > abs(direction.z)) { color.rgb = vec3(direction.x > 0.0 ? 1.0 : 0.5, 0, 0); }
        // else if (abs(direction.y) > abs(direction.x) && abs(direction.y) > abs(direction.z)) { color.rgb = vec3(0,direction.y > 0.0 ? 1.0 : 0.5, 0); }
        // else if (abs(direction.z) > abs(direction.y) && abs(direction.z) > abs(direction.x)) { color.rgb = vec3(0,0,direction.z > 0.0 ? 1.0 : 0.5); }


#ifdef PROBE_USE_IMAGE_DEPTH
        if (data.distance < 0.0) { // fix sky distance
            // data.distance = grid_max_distance;
        } else {

            float dist = clamp(data.distance - 0.01, 0.0, grid_max_distance); 
            vec2 D = vec2(dist, dist*dist);
            if (probes[probe_id].samples > 0) {
                // float a = 1. / float(probes[probe_id].samples + 1);
                // D = mix(current_depth, D, a);
             
                D = mix(current_depth, D, vec2(0.5));

            }
            imageStore(uProbeTexture[1], ivec2(depth_uv * visibility_texture_size), vec4(D, 0.0, 0.0));
        }
#endif

#ifdef PROBE_USE_SH_COLOR
        // SH9Depth depth_sample = depth_to_sh9(direction.xyz, data.distance);
        // probes[probe_id].depth = accumulate_depth(probes[probe_id].depth, depth_sample, 1.);
        SH9Irradiance irradiance_sample = irradiance_to_sh9(direction.xyz, color.rgb);
        probes[probe_id].irradiance = accumulate_irradiance(probes[probe_id].irradiance, irradiance_sample, 1.);
#else 
        vec3 texel_dir = decode_oct(color_uv);

        float weight = saturate(dot(texel_dir, -direction.xyz));

        if (probes[probe_id].samples > 0) {
            color.rgb = mix(current_color, color.rgb, vec3(0.250));
            // D = mix(current_depth, D, vec2(2.0));
        }

        // imageAtomicExchange(uProbeTexture[0], color_pixel, vec4(color.rgb * weight, 1.0));

        
        imageStore(uProbeTexture[0], color_pixel, vec4(color.rgb, 1.0));
#endif
        probes[probe_id].samples += 1;
    }
}
