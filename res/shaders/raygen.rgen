#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_scalar_block_layout : enable

#include "raycommon.glsl"
#include "rng.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba16f) uniform image2D image;
layout(binding = 2, set = 0) uniform sampler2D uTextureCache[4096];
layout(binding = 3, set = 0) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;

layout(location = 0) rayPayloadEXT RayData data;
layout(location = 2) rayPayloadEXT bool shadowed;


layout( push_constant ) uniform constants
{
    uint kFrame;
    uint kSuperSample;
};

#define SAMPLE_COUNT 2

void main() 
{
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, kFrame);

	vec4 origin = cam.viewInverse * vec4(0,0,0,1);

	float tmin = 0.001;
	float tmax = 10000.0;

    vec3 image_color = vec3(0.0);

    for (uint s = 0; s < SAMPLE_COUNT * max(1, kSuperSample); s++) {
        float r1 = rnd(seed);
        float r2 = rnd(seed);

        vec2 subpixel_jitter = vec2(r1, r2)*(kSuperSample>0?1.0:0.0);

        const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + subpixel_jitter;
        const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
        vec2 d = inUV * 2.0 - 1.0;
        vec4 target = cam.projInverse * vec4(d.x, d.y, 1, 1) ;

	    vec4 direction = cam.viewInverse*vec4(normalize(target.xyz), 0) ;

        vec3 color=vec3(0.0);
        
        for (int i = 0; i < 2; i++) {
            data.normal = direction.xyz;
            data.color = vec3(0.0);

            traceRayEXT(topLevelAS, 
                gl_RayFlagsNoneEXT, 
                // gl_RayFlagsOpaqueEXT, 
                0xff, 
                0, 
                0, 
                0, 
                origin.xyz, 
                tmin, 
                direction.xyz, 
                tmax, 
                0);

            if (data.distance < 0.0) {
                color += data.color;
                break;
            }
            else if (data.reflector >= 1.0) {
                image_color += data.color * 0.5;// / pow(2, i);
                vec3 h = origin.xyz + direction.xyz * data.distance;
                origin.xyz = h.xyz + data.normal * 0.001f;
                direction.xyz = reflect(direction.xyz, data.normal);
                // direction.xyz = data.normal = normalize(direction.xyz + hemisphere_random(direction.xyz, seed) * 0.05);
            } else {
                color += data.color;
                break;
            } 
        }
        image_color += color;
    }

    image_color /= SAMPLE_COUNT * max(1,kSuperSample);

    if(kFrame%3 > 0 && kSuperSample > 0) {
        float a         = 1.0f / float(kFrame + 1);
        vec3  old_color = imageLoad(image, ivec2(gl_LaunchIDEXT.xy)).xyz;

        // if (distance(old_color, image_color) < 0.25) {
            imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(mix(old_color, image_color, a), 1.f));
        // } else {
            // imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(image_color, 1.f));
        // }

    } else {
        imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(image_color, 1.f));
    }
}
