#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable

#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

hitAttributeEXT vec2 attribs;

#include "raycommon.glsl"

layout(binding = 2, set = 0) uniform sampler2D uTextureCache[4096];

layout(set = 0, binding = 4, scalar) buffer MeshDesc_ { MeshDesc i[]; } uMeshDesc;

layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Positions of an object
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices

void main()
{
    MeshDesc mesh = uMeshDesc.i[gl_InstanceCustomIndexEXT];
    Vertices vertices = Vertices(mesh.vertex_ptr);
    Indices indices = Indices(mesh.index_ptr);

    const vec3 bary = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);

    ivec3 tri = indices.i[gl_PrimitiveID];

    Vertex v0 = vertices.v[tri.x];
    Vertex v1 = vertices.v[tri.y];
    Vertex v2 = vertices.v[tri.z];

    vec2 uv = (v0.t * bary.x + v1.t * bary.y + v2.t * bary.z);
    vec4 albedo = texture(uTextureCache[nonuniformEXT(mesh.texture_id%4096)], uv);

    if (albedo.a < 0.9) {
        ignoreIntersectionEXT;
    }

}