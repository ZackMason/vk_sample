#version 460

#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable

#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

hitAttributeEXT vec2 attribs;

#include "utl.glsl"
#include "lighting.glsl"
#include "raycommon.glsl"
#include "engine.glsl"

layout(binding = 2, set = 0) uniform sampler2D uTextureCache[4096];

// layout(set = 0, binding = 4, scalar) buffer MeshDesc_ { MeshDesc i[]; } uMeshDesc;
layout(set = 0, binding = 4, scalar) readonly buffer GfxEntity_ { Entity e[]; } uEntityBuffer;

layout(buffer_reference, scalar) buffer Vertices {Vertex v[]; }; // Positions of an object
layout(buffer_reference, scalar) buffer Indices {ivec3 i[]; }; // Triangle indices


void main()
{
    // MeshDesc mesh = uMeshDesc.i[gl_InstanceCustomIndexEXT];
    Entity entity = uEntityBuffer.e[gl_InstanceCustomIndexEXT];
    Vertices vertices = Vertices(entity.vertex_start);
    Indices indices = Indices(entity.index_start);

    const vec3 bary = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);

    ivec3 tri = indices.i[gl_PrimitiveID];

    Vertex v0 = vertices.v[tri.x];
    Vertex v1 = vertices.v[tri.y];
    Vertex v2 = vertices.v[tri.z];

    vec2 uv = (v0.t * bary.x + v1.t * bary.y + v2.t * bary.z);
    vec4 albedo = texture(uTextureCache[nonuniformEXT(entity.albedo%4096)], uv);

    if (albedo.a < 0.2) {
        ignoreIntersectionEXT;
    }

}