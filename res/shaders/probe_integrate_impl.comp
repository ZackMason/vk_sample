
#include "utl.glsl"
#include "rng.glsl"
#include "packing.glsl"

layout( push_constant ) uniform constants
{
	uint 		kFrame;
};

layout( std140, set = 0, binding = 0 ) uniform sporadicBuf
{
	int		uMode;
	int		uUseLighting;
	int		uNumInstances;
	float 	uTime;
} Sporadic;

layout(binding = 1, set = 0, rgba16f) uniform image2D uProbeTexture[2];
layout(binding = 1, set = 0) uniform sampler2D uProbeSampler[3];

#define LIGHT_PROBE_BINDING_INDEX 4
#define LIGHT_PROBE_SET_INDEX 0
#define LIGHT_PROBE_SET_READ_WRITE 

#include "material.glsl"
#include "ddgi.glsl"


layout(std430, set = 0, binding = 2, scalar) readonly buffer ProbeSettingsBuffer {
	LightProbeSettings probe_settings;
};

layout(set = 0, binding = 3, scalar) readonly buffer ProbeResultsBuffer {
    ProbeRayResult probe_results[];
};
layout(set = 0, binding = 3, scalar) readonly buffer PackedProbeResultsBuffer {
    ProbeRayPacked packed_probe_results[];
};


#define CACHE_SIZE 64
shared vec4 direction_depth[CACHE_SIZE];
#ifdef INTEGRATE_DEPTH
layout(local_size_x = PROBE_VISIBILITY_TOTAL, local_size_y = PROBE_VISIBILITY_TOTAL, local_size_z = 1) in;
#else
shared vec3 radiance[CACHE_SIZE];
layout(local_size_x = PROBE_IRRADIANCE_TOTAL, local_size_y = PROBE_IRRADIANCE_TOTAL, local_size_z = 1) in;
#endif

#ifdef INTEGRATE_DEPTH
const ivec4 border_offsets[68] = ivec4[](
    ivec4(16, 1, 1, 0),
    ivec4(15, 1, 2, 0),
    ivec4(14, 1, 3, 0),
    ivec4(13, 1, 4, 0),
    ivec4(12, 1, 5, 0),
    ivec4(11, 1, 6, 0),
    ivec4(10, 1, 7, 0),
    ivec4(9, 1, 8, 0),
    ivec4(8, 1, 9, 0),
    ivec4(7, 1, 10, 0),
    ivec4(6, 1, 11, 0),
    ivec4(5, 1, 12, 0),
    ivec4(4, 1, 13, 0),
    ivec4(3, 1, 14, 0),
    ivec4(2, 1, 15, 0),
    ivec4(1, 1, 16, 0),
    ivec4(16, 16, 1, 17),
    ivec4(15, 16, 2, 17),
    ivec4(14, 16, 3, 17),
    ivec4(13, 16, 4, 17),
    ivec4(12, 16, 5, 17),
    ivec4(11, 16, 6, 17),
    ivec4(10, 16, 7, 17),
    ivec4(9, 16, 8, 17),
    ivec4(8, 16, 9, 17),
    ivec4(7, 16, 10, 17),
    ivec4(6, 16, 11, 17),
    ivec4(5, 16, 12, 17),
    ivec4(4, 16, 13, 17),
    ivec4(3, 16, 14, 17),
    ivec4(2, 16, 15, 17),
    ivec4(1, 16, 16, 17),
    ivec4(1, 16, 0, 1),
    ivec4(1, 15, 0, 2),
    ivec4(1, 14, 0, 3),
    ivec4(1, 13, 0, 4),
    ivec4(1, 12, 0, 5),
    ivec4(1, 11, 0, 6),
    ivec4(1, 10, 0, 7),
    ivec4(1, 9, 0, 8),
    ivec4(1, 8, 0, 9),
    ivec4(1, 7, 0, 10),
    ivec4(1, 6, 0, 11),
    ivec4(1, 5, 0, 12),
    ivec4(1, 4, 0, 13),
    ivec4(1, 3, 0, 14),
    ivec4(1, 2, 0, 15),
    ivec4(1, 1, 0, 16),
    ivec4(16, 16, 17, 1),
    ivec4(16, 15, 17, 2),
    ivec4(16, 14, 17, 3),
    ivec4(16, 13, 17, 4),
    ivec4(16, 12, 17, 5),
    ivec4(16, 11, 17, 6),
    ivec4(16, 10, 17, 7),
    ivec4(16, 9, 17, 8),
    ivec4(16, 8, 17, 9),
    ivec4(16, 7, 17, 10),
    ivec4(16, 6, 17, 11),
    ivec4(16, 5, 17, 12),
    ivec4(16, 4, 17, 13),
    ivec4(16, 3, 17, 14),
    ivec4(16, 2, 17, 15),
    ivec4(16, 1, 17, 16),
    ivec4(16, 16, 0, 0),
    ivec4(1, 16, 17, 0),
    ivec4(16, 1, 0, 17),
    ivec4(1, 1, 17, 17)
);
#else
const ivec4 border_offsets[36] = ivec4[](
    ivec4(8, 1, 1, 0),
    ivec4(7, 1, 2, 0),
    ivec4(6, 1, 3, 0),
    ivec4(5, 1, 4, 0),
    ivec4(4, 1, 5, 0),
    ivec4(3, 1, 6, 0),
    ivec4(2, 1, 7, 0),
    ivec4(1, 1, 8, 0),
    ivec4(8, 8, 1, 9),
    ivec4(7, 8, 2, 9),
    ivec4(6, 8, 3, 9),
    ivec4(5, 8, 4, 9),
    ivec4(4, 8, 5, 9),
    ivec4(3, 8, 6, 9),
    ivec4(2, 8, 7, 9),
    ivec4(1, 8, 8, 9),
    ivec4(1, 8, 0, 1),
    ivec4(1, 7, 0, 2),
    ivec4(1, 6, 0, 3),
    ivec4(1, 5, 0, 4),
    ivec4(1, 4, 0, 5),
    ivec4(1, 3, 0, 6),
    ivec4(1, 2, 0, 7),
    ivec4(1, 1, 0, 8),
    ivec4(8, 8, 9, 1),
    ivec4(8, 7, 9, 2),
    ivec4(8, 6, 9, 3),
    ivec4(8, 5, 9, 4),
    ivec4(8, 4, 9, 5),
    ivec4(8, 3, 9, 6),
    ivec4(8, 2, 9, 7),
    ivec4(8, 1, 9, 8),
    ivec4(8, 8, 0, 0),
    ivec4(1, 8, 9, 0),
    ivec4(8, 1, 0, 9),
    ivec4(1, 1, 9, 9)
);
#endif

// #define SHARED_MEMORY

void main() {
    // if (kFrame == 0) return;
    uint odd_frame = kFrame % 2;
    bool adjust_offset = true;


#ifdef INTEGRATE_DEPTH
    bool is_border = (gl_LocalInvocationID.x == 0 || gl_LocalInvocationID.x == (PROBE_VISIBILITY_TOTAL-1)) 
        || (gl_LocalInvocationID.y == 0 || gl_LocalInvocationID.y == (PROBE_VISIBILITY_TOTAL-1));
#else
    bool is_border = (gl_LocalInvocationID.x == 0 || gl_LocalInvocationID.x == (PROBE_IRRADIANCE_TOTAL-1))
        || (gl_LocalInvocationID.y == 0 || gl_LocalInvocationID.y == (PROBE_IRRADIANCE_TOTAL-1));
#endif

    uint probe_id = gl_WorkGroupID.x;

    float offset_distance = max(probe_settings.grid_size.x, max(probe_settings.grid_size.y, probe_settings.grid_size.z)) * 0.2;
#ifdef INTEGRATE_DEPTH
    if (kFrame == 0) {
        probes[probe_id].p = vec3(0.0);
    }

    uint ray_count = probes[probe_id].ray_back_count & 0xffff;
    uint backface_count = (probes[probe_id].ray_back_count>>16) & 0xffff;
    bool backface_threshold = backface_count > 15000;

    if (backface_threshold || ray_count > 0xff00) {
        probes[probe_id].ray_back_count = ((ray_count>>1)&0xffff)|(((backface_count>>1)&0xffff)<<16);
        if (backface_threshold) {
            uint seed = kFrame + probe_id;
            probes[probe_id].p = sphere_random(seed) * probe_settings.grid_size.x * 0.5;
        }
    }
#endif

    
    uvec3 probe_coord = index_1d(probe_settings.dim, probe_id);


#ifdef INTEGRATE_DEPTH
    uvec2 pixel_top_left = probe_depth_pixel(probe_coord, probe_settings.dim);
    uvec2 pixel = pixel_top_left + gl_LocalInvocationID.xy-1; 
    const vec3 texel_dir = decode_oct(((gl_LocalInvocationID.xy + 0.5) / vec2(PROBE_VISIBILITY_TOTAL)) * 2 - 1);
#else
    uvec2 pixel_top_left = probe_color_pixel(probe_coord, probe_settings.dim);
    uvec2 pixel = pixel_top_left + gl_LocalInvocationID.xy-1; 
    const vec3 texel_dir = decode_oct(((gl_LocalInvocationID.xy + 0.5) / vec2(PROBE_IRRADIANCE_TOTAL)) * 2 - 1);
#endif

    vec4 result = vec4(0.0);

    vec3 new_offset = vec3(0.0);



    uint remaining_rays = 128;
    // uint remaining_rays = 64;
    uint offset = 0;

    uint start_index = probe_ray_start(probe_id, odd_frame);

    if (!is_border)
    {

    #ifdef SHARED_MEMORY
        while (remaining_rays > 0 && remaining_rays <= PROBE_RAY_MAX) {
            uint num_rays = min(CACHE_SIZE, remaining_rays);
            if (gl_LocalInvocationIndex < num_rays) {
                ProbeRayPacked packed_ray = packed_probe_results[start_index + gl_LocalInvocationIndex + offset];
                ProbeRayResult ray;
                // ray.radiance = unpack_rgbe(packed_ray.radiance.x);
                ray.radiance = unpack_half3(packed_ray.radiance);
                ray.direction = unpack_normal(packed_ray.direction_depth.x);
                ray.depth = asfloat(packed_ray.direction_depth.y).x;
        #ifdef INTEGRATE_DEPTH
        #else
                radiance[gl_LocalInvocationIndex] = ray.radiance;
        #endif
                direction_depth[gl_LocalInvocationIndex] = vec4(ray.direction, ray.depth);
            }

            barrier();
            groupMemoryBarrier();

            for (uint ray_index = 0; ray_index < num_rays; ray_index++) {                
                ProbeRayResult ray;
        #ifdef INTEGRATE_DEPTH
                ray.depth = direction_depth[ray_index].w;
        #else
                ray.radiance = radiance[ray_index];
        #endif
                ray.direction = direction_depth[ray_index].xyz;
    #else
            uint probe_start_index = probe_ray_start(probe_id, odd_frame);
            for (uint ray_index = 0; ray_index < remaining_rays; ray_index++) {
                ProbeRayPacked packed_ray = packed_probe_results[start_index + ray_index];
                ProbeRayResult ray;// = probe_results[probe_start_index + ray_index];
                // ray.radiance = unpack_rgbe(packed_ray.radiance.x);
                ray.radiance = unpack_half3(packed_ray.radiance);
                ray.direction = unpack_normal(packed_ray.direction_depth.x);
                ray.depth = asfloat(packed_ray.direction_depth.y);
    #endif

                float weight = 0.0;


                weight = saturate(dot(ray.direction, texel_dir));

        #ifdef INTEGRATE_DEPTH
                if (abs(ray.depth) < offset_distance) 
                {
                    new_offset -= ray.direction * (offset_distance - abs(ray.depth));
                }
        #endif

                if (weight > 0.0001) 
                {

        #ifdef INTEGRATE_DEPTH
                    ray.depth = abs(ray.depth);
                    weight = pow(weight, probe_settings.depth_sharpness);

                    result += vec4(ray.depth * weight, ray.depth * ray.depth * weight, 1.0, weight);
        #else
                    // ignore backface
                    if (ray.depth > 0.0) 
                    {
                        result += vec4(ray.radiance * weight, weight);
                    }
        #endif
                }
            }

    #ifdef SHARED_MEMORY
            barrier();
            groupMemoryBarrier();

            remaining_rays -= num_rays;
            offset += num_rays;
        }
    #else
    #endif

        float epsilon = 1e-9f;
        
        result.rgb *= 1.0 / (2.0f * max(result.a, epsilon));

    #ifdef INTEGRATE_DEPTH
        if (kFrame > 1) {
            vec3 current = imageLoad(uProbeTexture[1], ivec2(pixel)).rgb;
            result.rgb = max(vec3(0.0), mix(current.rgb, result.rgb, probe_settings.hysteresis));
        }
        imageStore(uProbeTexture[1], ivec2(pixel), vec4(result.rgb, 1.0));

        if (adjust_offset && gl_LocalInvocationID.y == 1 && gl_LocalInvocationID.y == 1) {
            vec3 probe_offset = probes[probe_id].p;
            vec3 max_offset = vec3(probe_settings.grid_size*0.5);
            probe_offset = mix(probe_offset, new_offset, 0.01);
            probe_offset = clamp(probe_offset, -max_offset, max_offset); 
            probes[probe_id].p = probe_offset;
        }
    #else
        // result.rgb = sqrt(result.rgb);

        if (kFrame > 1) {
            vec3 current = imageLoad(uProbeTexture[0], ivec2(pixel)).rgb;
            result.rgb = max(vec3(0.0), mix(current.rgb, result.rgb, probe_settings.hysteresis));
        }
        // result.rgb = abs(max(vec3(0.0), texel_dir.rgb));
        // result.rgb = abs(min(vec3(0.0), texel_dir.rgb));
        // result.rgb = texel_dir.rgb;

        result.x = isnan(result.x) ? 0.0 : result.x;
        result.y = isnan(result.y) ? 0.0 : result.y;
        result.z = isnan(result.z) ? 0.0 : result.z;
            
        imageStore(uProbeTexture[0], ivec2(pixel), vec4(result.rgb, 1.0));
    #endif
    }

    barrier();
    groupMemoryBarrier();
    
    // if (false) 
    {
#ifdef INTEGRATE_DEPTH
        for (uint i = gl_LocalInvocationIndex; i < 68; i += sqr(PROBE_VISIBILITY_TOTAL)) {
            uvec2 src = pixel_top_left - 1 + border_offsets[i].xy;
            uvec2 dst = pixel_top_left - 1 + border_offsets[i].zw;
            imageStore(uProbeTexture[1], ivec2(dst), imageLoad(uProbeTexture[1], ivec2(src)));
        }
#else
        for (uint i = gl_LocalInvocationIndex; i < 36; i += sqr(PROBE_IRRADIANCE_TOTAL)) {
            uvec2 src = pixel_top_left - 1 + border_offsets[i].xy;
            uvec2 dst = pixel_top_left - 1 + border_offsets[i].zw;
            imageStore(uProbeTexture[0], ivec2(dst), imageLoad(uProbeTexture[0], ivec2(src)));
        }
#endif
        // return;
    }
    

}
